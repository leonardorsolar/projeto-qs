# Planejamento

O objetivo aqui é descobrir as melhores técnicas para escrever código testável, flexível e sustentável.
Estamos buscando formas de reduzir a complexidade, não de aumentá-la.

CHA:
Competência: conhecimento, habilidade e atitute
Conhecimento 15%
Habilidade: 25%
Atitude: 60%

## Passo 1: Crie a seguinte estutura de pastas:

```lua
Minicurso
│
├── 00 Minicurso
│ ├── ...
│   └── ...
│
├── 01 Planejamento
│ ├── Visão
│   └── 01 Painel de Visão de Produto.md
│   └── 02 Mapa de Empatia.md
└──
```

## Passo 2: Crie a visão do produto de software e cole no arquivo 01 Painel de Visão de Produto.md

**cgatGpt:** Crie a visão do projeto conta bancária com o login e registro de usuários que contenha:
Vision (Visão)
Target Group (Público alvo)
Needs (Necessidades)
Product (Produto)
Business Goals (Objetivos de negócio)
Competitors (Concorrentes)
Revenue Streams (Geração de receita)
Cost Factors (Custo)
Channels (Canais)

## Passo 3: Crie a visão do produto de software e cole no arquivo 02 Mapa de Empatia.md

**cgatGpt:** Crie o mapa de empatia do projeto conta bancária com o login e registro de usuários que contenha:

1. O que a persona vê?
2. O que a persona ouve?
3. O que a persona pensa e sente?
4. O que a persona fala e faz?
5. Quais são as dores da persona?
6. Quais as necessidades da persona?

Questionamentos:
Como fazemos o escopo de um projeto?
Como iniciamos um projeto?
Qual é a melhor maneira de aprender o domínio?
Qual é a melhor maneira de extrair os requisitos do cliente?
Como damos boas estimativas?
Como mantemos o cliente feliz (para que ele continue nos pagando)?
Como equilibramos o poder entre o cliente e nós? O que o cliente deve ter uma palavra a dizer sobre isso e o que devemos ter a palavra final?
Quão envolvido o cliente deve estar durante todo o projeto?
O que acontece se não conseguirmos cumprir os prazos?
Como desenvolvemos a estrutura inicial de um projeto?
Como decidimos o que constitui uma boa arquitetura?
Devemos levar em conta o tempo que leva para configurar as coisas?
Quando o design real acontece?
Como evitar bugs e regressões na base de código?
Como testamos efetivamente os requisitos?
Devemos usar mocks? Por que ou por que não?
O que fazemos em relação aos requisitos não funcionais? Como os descobrimos? Como os testamos?
Como mantemos nosso código escalável, flexível e sustentável?
Como sabemos quando terminamos?
